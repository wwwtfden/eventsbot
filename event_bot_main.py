import logging
import configparser
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
    JobQueue,
    PicklePersistence
)
import sqlite3
from datetime import datetime, timedelta, time

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.DEBUG  # –ò–∑–º–µ–Ω–∏—Ç–µ –Ω–∞ DEBUG –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
)

logger = logging.getLogger(__name__)

config = configparser.ConfigParser()
config.read('bot_config.ini', encoding='utf-8')
TOKEN = config['Main']['TOKEN']
ADMIN_ID = config.getint('Main', 'ADMIN_ID')  # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ int
DATABASE_NAME = config['Main']['DATABASE_NAME']

persistence = PicklePersistence(filepath="conversationbot")

# –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –º–µ–Ω—é
USER_COMMANDS = [
    ("üìÖ –°–ø–∏—Å–æ–∫ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π", "events"),
    ("üìå –ú–æ–∏ –∑–∞–ø–∏—Å–∏", "myevents"),
    ("‚ÑπÔ∏è –ü–æ–º–æ—â—å", "help")
]

ADMIN_COMMANDS = USER_COMMANDS + [
    ("üõ† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è–º–∏", "adminevents"),
    ("‚ûï –°–æ–∑–¥–∞—Ç—å –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ", "createevent")
]

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
(
    CREATE_NAME, CREATE_MAX, CREATE_END, CREATE_TIME,
    EDIT_CHOICE, EDIT_VALUE, DELETE_CONFIRM
) = range(7)


def is_admin(user_id: int) -> bool:
    return user_id == ADMIN_ID


class Database:
    def __init__(self):
        self.conn = sqlite3.connect(DATABASE_NAME)
        self.create_tables()

    def create_tables(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                max_participants INTEGER NOT NULL,
                end_date DATE NOT NULL,
                event_time TIME NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Å—Ç–æ–ª–±—Ü–æ–≤
        cursor.execute("PRAGMA table_info(events)")
        columns = [column[1] for column in cursor.fetchall()]
        required_columns = {'name', 'max_participants', 'end_date', 'event_time'}

        if not required_columns.issubset(columns):
            cursor.execute('DROP TABLE IF EXISTS events')
            self.create_tables()

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS registrations (
                user_id INTEGER NOT NULL,
                event_id INTEGER NOT NULL,
                username TEXT NOT NULL,
                registered_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (user_id, event_id),
                FOREIGN KEY (event_id) REFERENCES events(id)
            )
        ''')
        self.conn.commit()

    def add_event(self, name, max_participants, end_date, event_time):
        cursor = self.conn.cursor()
        cursor.execute('''
            INSERT INTO events (name, max_participants, end_date, event_time)
            VALUES (?, ?, ?, ?)
        ''', (name, max_participants, end_date, event_time))
        self.conn.commit()
        return cursor.lastrowid

    def delete_event(self, event_id):
        cursor = self.conn.cursor()
        cursor.execute('DELETE FROM events WHERE id = ?', (event_id,))
        cursor.execute('DELETE FROM registrations WHERE event_id = ?', (event_id,))
        self.conn.commit()

    def get_all_events(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT 
                e.id,
                e.name,
                e.max_participants,
                e.end_date,
                e.event_time,
                COUNT(r.user_id) as current_participants
            FROM events e
            LEFT JOIN registrations r ON e.id = r.event_id
            GROUP BY e.id
        ''')
        return cursor.fetchall()

    def register_user(self, user_id, username, event_id):
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                INSERT INTO registrations (user_id, event_id, username)
                VALUES (?, ?, ?)
            ''', (user_id, event_id, username))
            self.conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False

    def get_event_participants(self, event_id):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT username FROM registrations
            WHERE event_id = ?
        ''', (event_id,))
        return [row[0] for row in cursor.fetchall()]

    def check_available_slots(self, event_id):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT e.max_participants, COUNT(r.user_id)
            FROM events e
            LEFT JOIN registrations r ON e.id = r.event_id
            WHERE e.id = ?
        ''', (event_id,))
        max_p, current = cursor.fetchone()
        return max_p - current

    def get_user_events(self, user_id):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT e.id, e.name, e.end_date
            FROM events e
            JOIN registrations r ON e.id = r.event_id
            WHERE r.user_id = ?
        ''', (user_id,))
        return cursor.fetchall()

    def delete_registration(self, user_id, event_id):
        cursor = self.conn.cursor()
        cursor.execute('''
            DELETE FROM registrations
            WHERE user_id = ? AND event_id = ?
        ''', (user_id, event_id))
        self.conn.commit()
        return cursor.rowcount

    def update_event_field(self, event_id, field, value):
        cursor = self.conn.cursor()
        cursor.execute(f'''
            UPDATE events SET {field} = ? WHERE id = ?
        ''', (value, event_id))
        self.conn.commit()

    def delete_old_events(self):
        cursor = self.conn.cursor()
        week_ago = datetime.now() - timedelta(days=7)
        cursor.execute('''
            DELETE FROM events WHERE end_date < ?
        ''', (week_ago,))
        deleted = cursor.rowcount
        self.conn.commit()
        return deleted

    def get_event_by_id(self, event_id):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT
                e.id,
                e.name,
                e.max_participants,
                e.end_date,
                e.event_time,
                COUNT(r.user_id) as current_participants
            FROM events e
            LEFT JOIN registrations r ON e.id = r.event_id
            WHERE e.id = ?
            GROUP BY e.id
        ''', (event_id,))
        result = cursor.fetchone()
        if result:
            return {
                'id': result[0],
                'name': result[1],
                'max_participants': result[2],
                'end_date': result[3],  # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
                'event_time': result[4],
                'current_participants': result[5]
            }
        return None

db = Database()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥

async def check_admin_access(update: Update) -> bool:
    user = update.effective_user
    if not is_admin(user.id):
        message = update.message or update.callback_query.message
        await message.reply_text("‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞!")
        return False
    return True

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("–°–æ–∑–¥–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    context.user_data.clear()
    return ConversationHandler.END

async def cancel_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("‚úñÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ")
    context.user_data.clear()
    return ConversationHandler.END

async def show_events(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        events = db.get_all_events()
        message = update.message or update.callback_query.message

        if not events:
            await message.reply_text("–°–µ–π—á–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π.")
            return

        keyboard = []
        for event in events:
            event_id, name, max_p, end_date, event_time, current = event
            available = max_p - current
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è
            formatted_date = datetime.strptime(end_date, "%Y-%m-%d").strftime("%d.%m.%Y")
            event_text = f"{name}\n {formatted_date} {event_time}\n {available} —Å–≤–æ–±." #üé´ –°–≤–æ–±–æ–¥–Ω–æ: {available}/{max_p}
            keyboard.append([InlineKeyboardButton(event_text, callback_data=f"event_{event_id}")])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ:", reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Error in show_events: {str(e)}", exc_info=True)
        await message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π")


async def event_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data.startswith("event_"):
        event_id = int(query.data.split("_")[1])
        available = db.check_available_slots(event_id)

        if available > 0:
            success = db.register_user(
                query.from_user.id,
                query.from_user.username,
                event_id
            )

            if success:
                await query.edit_message_text(
                    f"‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω—ã –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ! –û—Å—Ç–∞–ª–æ—Å—å –º–µ—Å—Ç: {available - 1}"
                )
            else:
                await query.edit_message_text("‚ö†Ô∏è –í—ã —É–∂–µ –∑–∞–ø–∏—Å–∞–Ω—ã –Ω–∞ —ç—Ç–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ!")
        else:
            await query.edit_message_text("‚ö†Ô∏è –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—Å–µ –º–µ—Å—Ç–∞ –∑–∞–Ω—è—Ç—ã!")


# –ê–¥–º–∏–Ω—Å–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
def get_event_by_id(self, event_id):
    cursor = self.conn.cursor()
    cursor.execute('''
        SELECT
            e.id,
            e.name,
            e.max_participants,
            e.end_date,
            e.event_time,
            COUNT(r.user_id) as current_participants
        FROM events e
        LEFT JOIN registrations r ON e.id = r.event_id
        WHERE e.id = ?
        GROUP BY e.id
    ''', (event_id,))
    result = cursor.fetchone()
    if result:
        return {
            'id': result[0],
            'name': result[1],
            'max_participants': result[2],
            'end_date': result[3],  # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
            'event_time': result[4],
            'current_participants': result[5]
        }
    return None

async def handle_back_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await admin_events(update, context)


async def admin_actions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data.startswith("view_"):
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
        if not await check_admin_access(update):
            return

        event_id = int(query.data.split("_")[1])
        participants = db.get_event_participants(event_id)

        participants_text = "–£—á–∞—Å—Ç–Ω–∏–∫–∏:\n" + "\n".join(
            [f"{i + 1}. @{username}" for i, username in enumerate(participants)]
        ) if participants else "–ù–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"

        await query.edit_message_text(
            text=f"üìã –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:\n\n{participants_text}",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="adminevents")]
            ])
        )
        return

    elif query.data == "adminevents":
        await admin_events(update, context)

    elif query.data.startswith("delete_"):
        event_id = int(query.data.split("_")[1])
        context.user_data['delete_event_id'] = event_id
        keyboard = [
            [InlineKeyboardButton("‚úÖ –î–∞", callback_data="confirm_delete")],
            [InlineKeyboardButton("‚ùå –ù–µ—Ç", callback_data="cancel_delete")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ?",
            reply_markup=reply_markup
        )
        return DELETE_CONFIRM  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è


async def confirm_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()

        if query.data == "confirm_delete":
            event_id = context.user_data.get('delete_event_id')
            if event_id:
                event_exists = any(e[0] == event_id for e in db.get_all_events())
                if not event_exists:
                    await query.edit_message_text("‚ùå –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É–∂–µ –±—ã–ª–æ —É–¥–∞–ª–µ–Ω–æ")
                    return ConversationHandler.END
                else:
                    db.delete_event(event_id)
                    await query.edit_message_text("‚úÖ –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ!")

            else:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        else:
            await query.edit_message_text("‚ùå –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ")

        context.user_data.clear()
        return ConversationHandler.END
    except Exception as e:
            logger.error(f"Error deleting event: {str(e)}")
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è")


async def create_event(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
    if not await check_admin_access(update):
        return ConversationHandler.END

    # –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ
    context.user_data.clear()

    # –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ callback_query –∏–ª–∏ message
    query = update.callback_query
    if query:
        await query.answer()
        message = query.message
    else:
        message = update.message

    await message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:")
    return CREATE_NAME  # –Ø–≤–Ω–æ–µ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è


async def create_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['event_name'] = update.message.text
        logger.info(f"Received event name: {context.user_data['event_name']}")

        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:")
        return CREATE_MAX
    except Exception as e:
        logger.error(f"Error in create_name: {str(e)}")
        return ConversationHandler.END


async def create_max(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        max_p = int(update.message.text)
        if max_p <= 0:
            raise ValueError
        context.user_data['event_max'] = max_p
        logger.info(f"Received max participants: {max_p}")

        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è (–ì–ì–ì–ì-–ú–ú-–î–î):")
        return CREATE_END
    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ! –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ:")
        return CREATE_MAX


async def create_end(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"Received end date: {update.message.text}")
    try:
        end_date = datetime.strptime(update.message.text, "%Y-%m-%d").date()
        today = datetime.now().date()

        if end_date < today:
            await update.message.reply_text("–î–∞—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ –ø—Ä–æ—à–ª–æ–º!")
            return CREATE_END

        context.user_data['end_date'] = end_date
        # message = update.message or update.callback_query.message
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú:")
        return CREATE_TIME
    except ValueError:
        # message = update.message or update.callback_query.message
        await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:")
        return CREATE_END


async def create_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    time_str = update.message.text
    logger.info(f"Received time: {time_str}")
    try:
        # –ü–∞—Ä—Å–∏–º –≤—Ä–µ–º—è –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
        event_time = datetime.strptime(time_str, "%H:%M").time()
        time_formatted = event_time.strftime("%H:%M")  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        if not all(key in context.user_data for key in ['event_name', 'event_max', 'end_date']):
            logger.error("Missing required data in context")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø–æ—Ç–µ—Ä—è–Ω—ã –¥–∞–Ω–Ω—ã–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
            return ConversationHandler.END

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        name = context.user_data['event_name']
        max_p = context.user_data['event_max']
        end_date = context.user_data['end_date'].strftime("%Y-%m-%d")  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –≤ —Å—Ç—Ä–æ–∫—É

        # –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –≤ –ë–î
        db.add_event(name, max_p, end_date, time_formatted)
        await update.message.reply_text("‚úÖ –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–æ!")
        return ConversationHandler.END

    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ß–ß:–ú–ú:")
        return CREATE_TIME
    except Exception as e:
        logger.error(f"Error in create_time: {str(e)}", exc_info=True)
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è")
        return ConversationHandler.END

async def admin_events(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if not await check_admin_access(update):
            return

        events = db.get_all_events()
        if not events:
            message = update.message or update.callback_query.message
            await message.reply_text("–ù–µ—Ç –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è.")
            return

        keyboard = []
        for event in events:
            event_id, name, max_p, end_date, event_time, current = event
            text = f"{name} ({current}/{max_p})"
            keyboard.append([
                InlineKeyboardButton(text, callback_data=f"view_{event_id}"),
                InlineKeyboardButton("‚úèÔ∏è", callback_data=f"edit_{event_id}"),
                InlineKeyboardButton("‚ùå", callback_data=f"delete_{event_id}")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)
        message = update.message or update.callback_query.message
        await message.reply_text("–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è–º–∏:", reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Error in admin_events: {str(e)}", exc_info=True)
        await message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è")


async def my_events(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message or update.callback_query.message
    events = db.get_user_events(update.effective_user.id)

    if not events:
        await message.reply_text("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω–æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ")
        return

    keyboard = []
    for event in events:
        event_id, name, end_date = event
        text = f"{name} ( {end_date.split()[0]})"
        keyboard.append([InlineKeyboardButton(text, callback_data=f"unreg_{event_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await message.reply_text("–í–∞—à–∏ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:", reply_markup=reply_markup)


async def cancel_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    event_id = int(query.data.split("_")[1])
    db.delete_registration(update.effective_user.id, event_id)

    await query.edit_message_text("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞!")


async def edit_event_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    try:
        event_id = int(query.data.split("_")[1])
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è
        if not any(e[0] == event_id for e in db.get_all_events()):
            await query.edit_message_text("‚ùå –ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!")
            return ConversationHandler.END

        context.user_data['edit_event_id'] = event_id
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        keyboard = [
            [InlineKeyboardButton("–ù–∞–∑–≤–∞–Ω–∏–µ", callback_data="field_name")],
            [InlineKeyboardButton("–ú–∞–∫—Å. —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤", callback_data="field_max_participants")],
            [InlineKeyboardButton("–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è", callback_data="field_end_date")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=reply_markup)
        return EDIT_CHOICE

    except (IndexError, ValueError):
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã")
        return ConversationHandler.END


async def edit_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–∏
    event_id = context.user_data.get('edit_event_id')
    event = db.get_event_by_id(event_id)  # –ù—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –º–µ—Ç–æ–¥

    field = query.data.split("field_")[1]
    context.user_data['edit_field'] = field

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    current_value = {
        'name': event['name'],
        'max_participants': event['max_participants'],
        'end_date': event['end_date'].strftime("%Y-%m-%d"),
        'event_time': event['event_time']
    }[field]

    field_name = {
        'name': '–Ω–∞–∑–≤–∞–Ω–∏–µ',
        'max_participants': '–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤',
        'end_date': '–¥–∞—Ç—É –æ–∫–æ–Ω—á–∞–Ω–∏—è',
        'event_time': '–≤—Ä–µ–º—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è'
    }[field]

    await query.edit_message_text(
        f"–¢–µ–∫—É—â–µ–µ {field_name}: {current_value}\n"
        f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:"
    )
    return EDIT_VALUE


async def edit_value(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_data = context.user_data
    field = user_data.get('edit_field')
    event_id = user_data.get('edit_event_id')
    value = update.message.text
    event = db.get_event_by_id(event_id)

    try:
        if field == 'max_participants':
            new_max = int(value)
            current = event['current_participants']

            if new_max < current:
                await update.message.reply_text(
                    f"‚ùå –û—à–∏–±–∫–∞: {current} —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —É–∂–µ –∑–∞–ø–∏—Å–∞–Ω–æ!\n"
                    f"–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {current}\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:"
                )
                return EDIT_VALUE

            if new_max <= 0:
                await update.message.reply_text("‚ùå –ß–∏—Å–ª–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ 0!")
                return EDIT_VALUE

            db.update_event_field(event_id, field, new_max)
            await update.message.reply_text("‚úÖ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!")

        elif field == 'end_date':
            new_date = datetime.strptime(value, "%Y-%m-%d").date()
            if new_date < datetime.now().date():
                await update.message.reply_text("‚ùå –î–∞—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ –ø—Ä–æ—à–ª–æ–º!")
                return EDIT_VALUE

            db.update_event_field(event_id, field, new_date)
            await update.message.reply_text("‚úÖ –î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")

        elif field == 'name':
            if len(value) < 3:
                await update.message.reply_text("‚ùå –ù–∞–∑–≤–∞–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–µ (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞)!")
                return EDIT_VALUE

            db.update_event_field(event_id, field, value)
            await update.message.reply_text("‚úÖ –ù–∞–∑–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!")

        elif field == 'event_time':
            datetime.strptime(value, "%H:%M")
            db.update_event_field(user_data['edit_event_id'], 'event_time', value)
            await update.message.reply_text("–í—Ä–µ–º—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–æ!")

    except ValueError as e:
        error_msg = {
            'max_participants': "‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ!",
            'end_date': "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î",
            'event_time': "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ß–ß:–ú–ú"
        }.get(field, "‚ùå –û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞")

        await update.message.reply_text(f"{error_msg}\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:")
        return EDIT_VALUE

    return ConversationHandler.END

#
# async def auto_cleanup(context: ContextTypes.DEFAULT_TYPE):
#     deleted = db.delete_old_events()
#     if deleted > 0:
#         await context.bot.send_message(
#             ADMIN_ID,
#             f"–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–µ–Ω–æ {deleted} —Å—Ç–∞—Ä—ã—Ö –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–π"
#         )


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    keyboard = []

    if user.id == ADMIN_ID:
        buttons = [InlineKeyboardButton(text, callback_data=cmd) for text, cmd in ADMIN_COMMANDS]
    else:
        buttons = [InlineKeyboardButton(text, callback_data=cmd) for text, cmd in USER_COMMANDS]

    # –†–∞–∑–±–∏–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞ —Ä—è–¥—ã –ø–æ 2
    for i in range(0, len(buttons), 2):
        keyboard.append(buttons[i:i + 2])

    reply_markup = InlineKeyboardMarkup(keyboard)

    text = (
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –∑–∞–ø–∏—Å–∏ –Ω–∞ –∫–æ–Ω—è.\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    )
    message = update.message or update.callback_query.message
    await message.reply_text(text, reply_markup=reply_markup)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if update.callback_query:
        message = update.callback_query.message
        user = update.callback_query.from_user
    else:
        message = update.message
        user = update.effective_user

    help_text = [
        "üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:",
        "/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        "/events - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è",
        "/myevents - –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–∏ –∑–∞–ø–∏—Å–∏"
    ]

    if is_admin(user.id):
        help_text.extend([
            "\n‚öôÔ∏è –ê–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã:",
            "/adminevents - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è–º–∏",
            "/createevent - –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ"
        ])

    help_text.append("\n‚ÑπÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã!")

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤
    keyboard = []
    if is_admin(user.id):
        buttons = [InlineKeyboardButton(text, callback_data=cmd) for text, cmd in ADMIN_COMMANDS]
    else:
        buttons = [InlineKeyboardButton(text, callback_data=cmd) for text, cmd in USER_COMMANDS]

    # –†–∞–∑–±–∏–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞ —Ä—è–¥—ã –ø–æ 2
    for i in range(0, len(buttons), 2):
        keyboard.append(buttons[i:i + 2])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await message.reply_text("\n".join(help_text), reply_markup=reply_markup)


async def menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    try:
        # –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        logging.info(f"User {query.from_user.id} pressed button: {query.data}")

        command = query.data
        user_id = query.from_user.id

        if command == "help":
            await help_command(update, context)
        elif command == "events":
            await show_events(update, context)
        elif command == "myevents":
            await my_events(update, context)
        elif command == "adminevents":
            if user_id == ADMIN_ID:
                await admin_events(update, context)
            else:
                await query.edit_message_text("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω!")
        elif command == "createevent":
            if user_id == ADMIN_ID:
                await create_event(update, context)
            else:
                await query.edit_message_text("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω!")
        else:
            await query.edit_message_text("‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞")

    except Exception as e:
        logging.error(f"Error: {str(e)}", exc_info=True)
        await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞")


async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if update.message:
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞")
        elif update.callback_query:
            await update.callback_query.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞")
    except Exception as e:
        logger.error(f"Error in error handler: {str(e)}")

def main():
    application = (
        Application.builder()
        .token(TOKEN)
        .persistence(persistence)
        .build()
    )

    application.add_error_handler(error_handler)

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("events", show_events))
    application.add_handler(CommandHandler("myevents", my_events))

    # –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    application.add_handler(CommandHandler("adminevents", admin_events))

    create_event_conv = ConversationHandler(
        entry_points=[
            CommandHandler("createevent", create_event),
            CallbackQueryHandler(create_event, pattern="^createevent$")
        ],
        states={
            CREATE_NAME: [
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    create_name
                )
            ],
            CREATE_MAX: [
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    create_max
                )
            ],
            CREATE_END: [
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    create_end
                )
            ],
            CREATE_TIME: [
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND,
                    create_time
                )
            ]
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        persistent=True,
        name="create_event_conv"
    )
    application.add_handler(create_event_conv)

    edit_event_conv = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(edit_event_start, pattern=r"^edit_\d+$")  # –¢–æ–ª—å–∫–æ edit_ —Å —Ü–∏—Ñ—Ä–∞–º–∏
        ],
        states={
            EDIT_CHOICE: [
                CallbackQueryHandler(edit_choice, pattern=r"^field_(name|max_participants|end_date|event_time)$")
            ],
            EDIT_VALUE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, edit_value)
            ]
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            CallbackQueryHandler(cancel_edit, pattern="^cancel_edit$")
        ],
        persistent=True,
        name="edit_event_conv"
    )
    application.add_handler(edit_event_conv)

    delete_event_conv = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(admin_actions, pattern="^delete_")
        ],
        states={
            DELETE_CONFIRM: [
                CallbackQueryHandler(confirm_delete, pattern="^(confirm_delete|cancel_delete)$")
            ]
        },
        fallbacks=[],
        map_to_parent={  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é
            ConversationHandler.END: ConversationHandler.END
        }
    )
    application.add_handler(delete_event_conv)

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ callback-–∑–∞–ø—Ä–æ—Å–æ–≤
    application.add_handler(CallbackQueryHandler(event_button, pattern="^event_"))
    application.add_handler(CallbackQueryHandler(edit_event_start, pattern="^edit_"))
    application.add_handler(CallbackQueryHandler(cancel_registration, pattern="^unreg_"))
    application.add_handler(CallbackQueryHandler(admin_actions, pattern="^(view|delete)_"))
    application.add_handler(CallbackQueryHandler(menu_handler))
    application.add_handler(CallbackQueryHandler(handle_back_button, pattern="^adminevents$"))

    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    application.run_polling()

if __name__ == "__main__":
    main()
